#!/bin/bash

# TV Show Filename Cleaner
# Converts filenames like "The.Sopranos.S01E08.1080p.BluRay.x265-RARBG" 
# to "The Sopranos - S01E08"

# Function to clean a single filename
clean_filename() {
    local filename="$1"
    local extension="${filename##*.}"
    local basename="${filename%.*}"
    
    # Replace dots with spaces
    cleaned="${basename//\./ }"
    
    # Try multiple patterns to extract show name and episode info
    
    # Pattern 1: Show name followed by S##E## with extra info after
    # Example: "The Sopranos S01E08 1080p BluRay x265-RARBG"
    if [[ $cleaned =~ ^(.*)[[:space:]]+(S[0-9]{2}E[0-9]{2})[[:space:]].*$ ]]; then
        show_name="${BASH_REMATCH[1]}"
        episode="${BASH_REMATCH[2]}"
        
        echo "${show_name} - ${episode}"
        return 0
    fi
    
    # Pattern 2: Show name followed by S##E## at end (with optional spaces/dashes)
    # Example: "The Sopranos - S01E08" or "The Sopranos -  S01E08"
    if [[ $cleaned =~ ^(.*)[-[:space:]]+(S[0-9]{2}E[0-9]{2})[[:space:]]*$ ]]; then
        show_name="${BASH_REMATCH[1]}"
        episode="${BASH_REMATCH[2]}"
        
        # Clean up trailing spaces/dashes from show name
        show_name=$(echo "$show_name" | sed 's/[[:space:]-]*$//')
        
        echo "${show_name} - ${episode}"
        return 0
    fi
    
    # Pattern 3: Show name with S## E## format (space between season and episode)
    # Example: "The Sopranos S01 E08"
    if [[ $cleaned =~ ^(.*)[[:space:]]+(S[0-9]{2})[[:space:]]+(E[0-9]{2})[[:space:]]*$ ]]; then
        show_name="${BASH_REMATCH[1]}"
        season="${BASH_REMATCH[2]}"
        ep="${BASH_REMATCH[3]}"
        
        echo "${show_name} - ${season}${ep}"
        return 0
    fi
    
    # Could not parse - return empty string to signal failure
    return 1
}

# Main script
if [ $# -eq 0 ]; then
    echo "Usage: $0 [OPTIONS] <files...>"
    echo ""
    echo "Options:"
    echo "  -r, --rename    Actually rename the files (default: dry run)"
    echo "  -h, --help      Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0 *.mkv                    # Show what would be renamed"
    echo "  $0 -r *.mkv                 # Actually rename files"
    echo "  $0 The.Sopranos.S01E08.*    # Preview single file"
    exit 0
fi

# Parse options
RENAME=false
FILES=()

while [[ $# -gt 0 ]]; do
    case $1 in
        -r|--rename)
            RENAME=true
            shift
            ;;
        -h|--help)
            echo "TV Show Filename Cleaner"
            echo "Usage: $0 [OPTIONS] <files...>"
            exit 0
            ;;
        *)
            FILES+=("$1")
            shift
            ;;
    esac
done

# Process files
for file in "${FILES[@]}"; do
    if [ ! -f "$file" ]; then
        echo "File not found: $file"
        continue
    fi
    
    # Separate directory path and filename
    dir=$(dirname "$file")
    filename=$(basename "$file")
    extension="${filename##*.}"
    
    # Clean only the filename (not the full path)
    if new_basename=$(clean_filename "$filename"); then
        # Reconstruct the full path with cleaned filename
        if [ "$dir" = "." ]; then
            new_file="${new_basename}.${extension}"
        else
            new_file="${dir}/${new_basename}.${extension}"
        fi
        
        if [ "$RENAME" = true ]; then
            if [ "$file" != "$new_file" ]; then
                mv -v "$file" "$new_file"
            else
                echo "Skipping (no change needed): $file"
            fi
        else
            echo "$file -> $new_file"
        fi
    else
        # Could not parse - skip this file
        echo "Skipping (could not parse): $file"
    fi
done

if [ "$RENAME" = false ] && [ ${#FILES[@]} -gt 0 ]; then
    echo ""
    echo "This was a dry run. Use -r or --rename to actually rename files."
fi